{% extends "base.html" %}
{% load static %}
{% block title %}
{{ game.room_name }}
{% endblock %}

{% block content %}
<div class="max-w-[40%] mx-auto bg-gray-800 py-[20px] rounded-[10px] mt-[70px] mb-[70px]">
    <section class="max-w-[90%] mx-auto text-white text-center">
        <h1 class="text-[40px] font-semibold bg-gray-950 text-center py-[5px] rounded-[10px] mb-[40px]">
            {{ game.room_name }}</h1>
        <p id="turn" class="mb-[30px]">Current player: </p>

        <!-- CONTENEDOR DEL TABLERO  -->
        <div id="board_container" class="grid grid-cols-3 gap-[8px] mx-auto place-items-center
            w-[260px] h-[260px]">
        </div>
    </section>
</div>

<script>
// VARIABLES INICIALES
const roomName = "{{ game.room_name }}";
const userId = "{{ request.user.id }}";
let board = "{{ game.board }}".split("");
let state = "{{ game.state }}";   // estado inicial
const csrfToken = "{{ csrf_token }}"; // token para el form din√°mico
let activePlayer = "{{ game.active_player }}";

// FUNCION Q DIBUJA EL TABLERO
function renderBoard() {
    const container = document.getElementById("board_container");
    container.innerHTML = "";

    for (let i = 0; i < 9; i++) {
        const empty = board[i] === "_";
        // crear element dependiendo de si est√° libre u ocupado
        const cell = document.createElement(empty ? "button" : "div");

        // clases comunes
        if (empty) {
            // si la partida est√° activa, el bot√≥n es clickeable y con hover
            if (state === "active") {
                cell.className = "h-[80px] w-[80px] bg-gray-900 hover:bg-gray-700 text-[30px] rounded-[8px]";
                cell.onclick = () => playMove(i);
            } else {
                // partida terminada, mostrar casilla inactiva
                cell.className = "h-[80px] w-[80px] border border-gray-600 rounded-[8px]";
            }
        } else {
            cell.className = "h-[80px] w-[80px] border border-gray-600 rounded-[8px] flex items-center justify-center text-[35px] font-bold text-gray-200";
            cell.innerText = board[i];
        }

        container.appendChild(cell);
    }
}

// MUESTRA RESULTADO
function updateResultUI(data) {
    const section = document.querySelector("section");
    let resultDiv = document.getElementById("result_div");

    // creamos el contenedor si no existe
    if (!resultDiv) {
        resultDiv = document.createElement("div");
        resultDiv.id = "result_div";
        resultDiv.className = "mt-[30px]";
        section.appendChild(resultDiv);
    }

    if (data.state === "won") {
        resultDiv.innerHTML = `
            <p class="text-[22px] font-semibold text-green-400">
                üèÜ Winner: ${data.winner_username || "Jugador"}
            </p>
        `;
    } else if (data.state === "tie") {
        resultDiv.innerHTML = `
            <p class="text-[22px] font-semibold text-yellow-400">
                ü§ù Tie
            </p>
        `;
    } else {
        // si vuelve a active por alguna raz√≥n, lo limpiamos
        resultDiv.innerHTML = "";
    }
}

// A√ëADIR BOTON DE CERRAR
function ensureCloseButton(ownerId, gameId) {
    // solo el owner puede ver el boton
    if (ownerId !== userId) return;

    let closeForm = document.getElementById("close_room_form");
    if (closeForm) return; // ya existe

    const section = document.querySelector("section");

    closeForm = document.createElement("form");
    closeForm.id = "close_room_form";
    closeForm.method = "post";
    closeForm.action = "{% url 'games:close' %}";
    closeForm.className = "mt-[20px]";

    // usamos token CSRF que hemos puesto en csrfToken
    closeForm.innerHTML = `
        <input type="hidden" name="csrfmiddlewaretoken" value="${csrfToken}">
        <input type="hidden" name="name" value="${ game.id }">
        <button type="submit" class="bg-red-900 text-[20px] py-[10px] px-[40px] rounded-[8px] cursor-pointer">
            Close room
        </button>
    `;

    section.appendChild(closeForm);
}

// ACTUALIZAR TURNO
function updateTurnUI(data) {
    const el = document.getElementById("turn");
    if (!el) return;

    // Si partida terminada ‚Üí limpiar
    if (data.state !== "active") {
        el.innerText = "";
        return;
    }

    // Si a√∫n no hay jugador 2
    if (!data.player2_id) {
        el.innerText = "Waiting for player 2...";
        return;
    }

    // Mostrar nombre si viene en el payload
    if (data.turn_username) {
        el.innerText = `Current player: ${data.turn_username}`;
        return;
    }

    el.innerText = "";
}

// WEBSOCKET
const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
const wsUrl = protocol + "//" + window.location.host + "/ws/games/" + roomName + "/";
const socket = new WebSocket(wsUrl);

socket.onopen = function () {
    console.log("Connected to game socket", wsUrl);
    socket.send(JSON.stringify({ action: "join", user_id: userId }));
};

socket.onmessage = function (e) {
    const data = JSON.parse(e.data);
    console.log("DATA FROM SERVER:", data);
    if (!data) return;

    // actualizamos estado y tablero locales
    if (typeof data.board === "string") board = data.board.split("");
    if (data.state) state = data.state;
    if (data.active_player) activePlayer = data.active_player;


    // render y actualizar UI de resultado/bot√≥n/turno
    renderBoard();
    updateTurnUI(data);
    if (data.state && data.state !== "active") {
        updateResultUI(data);
        ensureCloseButton(data.owner_id, data.id);
    }
};

socket.onclose = function (e) {
    console.log("Socket closed", e); 
};

socket.onerror = function (err) {
    console.error("Socket error", err); 
};

// ENVIAR JUGADA
function playMove(index) {
    // si la partida ya ha terminado, no enviar
    if (state !== "active") return;

    socket.send(JSON.stringify({
        action: "move",
        user_id: userId,
        index: index
    }));
}

// RENDERIZADO INICIAL
renderBoard();
</script>

{% endblock %}